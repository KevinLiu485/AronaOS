目前为止，多核需要理解以下内容。
- 锁（RAII版本）的结构
- 多核的启动（SBI的使用）
- CPU结构体
- 一些死锁的避免

将来不排除可能会出现异构的东西。

### 多核的启动
大致流程：
- 在最开始，机器的一个CPU和被激活，
- 我们使用这个CPU，通过对应的SBI call唤醒剩下的cpu，
- 被启动的CPU，通过一个原子变量来判断自己是否使被启动的。
- 注意，
  - 一开始并不会四个核心一起启动。
  - qemu的参数需要加上smp相关的数据
  - 多核模块目前默认是关闭的，只有0号CPU会运行对应的OS。

### CPU结构体的相关信息
- Hart ID在启动的时候放在a0寄存器里面，因此可以通过添加一个main函数的参数，来获取这个变量，我们可以通过这个索引来唯一确定一个CPU的对应地址，为了方便debug，我们在结构体保存了id变量，但实际上并不是很需要。
- CPU的结构体没有采用一个数组进行统一管理，而是采用了硬编码，放在OS内核栈的栈底。
  - 设计目的：对于内核栈，我们没有办法知道一个内核栈他是否溢出。如果采用这个设计，CPU本身的不变量就会被破坏，在运行的时候就可以检测到，符合fail fast的原则，而不是在很久之后莫名其妙的指针飘飞。
- 如何获取自己的CPU结构体？
  - 通过读取某一个特定的寄存器，这个寄存器在一开始会是CPU对应的ID，之后就没有什么作用了，我们的OS直接将CPU结构体的地址放入了对应的内容，这样就可以直接读取对应寄存器，获取地址，从而得到对应的CPU结构体。

### 目前解决过的死锁问题
- INITPROC，回收子进程问题。
  - 问题描述：进程回收时，父进程会尝试获取子进程的锁，而当父进程退出的时候，他会把自己所有的子进程挂载到INIT PROC下面，子进程会尝试获取INIT PROC的锁，但是INIT PROC 是一个持有锁并且等待的进程，此时出现了一个死锁循环，
  - 解决方案：进程的is_zombie状态没有放在TaskInnerBlock里面，前面获取锁的目的是获取子进程是否死亡，我们通过放入一个原子变量避免了对应的锁，从而避免了循环引用。

## 进程
### 进程状态
- 由于内核整体采用了异步架构，使用了对应的三方库async_task，我们在开发的过程中发现，由于大部分的异步运行时都不是我们来写的，所以说我们并不是很需要管理对应的进程状态。第三方库会帮我们进行对应的管理。所以我们去掉了task status这个东西。我们仅仅需要管理的就是这个进程是否死亡（是否为zombie状态）

### 异步的进程
进程相关的系统调用基本都做了async 的处理，关于出让CPU结合异步架构做了统一的处理，这里需要强调一点是。当我们返回 pending 的时候，我们需要设置对应的 waker ，否则，这个进程会永远的不再醒来。

### 未来的设计阐述
未来可能会采用跟Linux一样的线程设计，将线程作为process进程的一个特殊情况进行管理。因为我发现Thread它本身。有一个main thread的概念，然后这个概念破坏了thread的一致性。因此摆烂了。

### 时间
关于时间管理相关的函数，我们采用了Rust本身自带的一个duration结构，以及rcore本身它带的一个timeSpect（这个也是nanosleep的输入结构体）
关于计时采用了内核的一个线程进行统一的计时。
